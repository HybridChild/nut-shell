#!/bin/bash
set -e

# Memory footprint analysis script for nut-shell
# Builds minimal reference binary with different feature combinations
# and generates a detailed size report

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MINIMAL_DIR="$SCRIPT_DIR/minimal"
REPORT="$SCRIPT_DIR/report.md"
TARGET="thumbv6m-none-eabi"
BINARY_NAME="minimal"

# Feature combinations to test
FEATURES=(
    "none"
    "authentication"
    "completion"
    "history"
    "async"
    "completion,history"
    "all"
)

# Color output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

printf "${BLUE}=== nut-shell Memory Footprint Analysis ===${NC}\n"
printf "\n"

# Check for required tools
echo "Checking for required tools..."
if ! command -v cargo &> /dev/null; then
    echo "Error: cargo not found"
    exit 1
fi

if ! command -v cargo-bloat &> /dev/null; then
    echo "Installing cargo-bloat..."
    cargo install cargo-bloat
fi

# Check if target is installed
if ! rustup target list | grep -q "$TARGET (installed)"; then
    echo "Installing target $TARGET..."
    rustup target add $TARGET
fi

# Navigate to minimal directory
cd "$MINIMAL_DIR"

# Remove old report to start fresh
rm -f "$REPORT"

# Store summary data for table
declare -a SUMMARY_ROWS

# Build and analyze each feature combination
for feat in "${FEATURES[@]}"; do
    printf "${GREEN}Analyzing: ${feat}${NC}\n"

    # Determine cargo flags
    if [ "$feat" = "none" ]; then
        FEAT_FLAGS="--no-default-features"
        FEAT_NAME="none"
    elif [ "$feat" = "all" ]; then
        FEAT_FLAGS="--all-features"
        FEAT_NAME="all features"
    else
        FEAT_FLAGS="--no-default-features --features $feat"
        FEAT_NAME="$feat"
    fi

    # Build
    echo "  Building..."

    # Verify memory.x exists (required for linking)
    if [ ! -f "memory.x" ]; then
        echo "  Warning: memory.x not found in $(pwd)"
        ls -la memory.x 2>&1 || true
    fi

    # Verify .cargo/config.toml exists
    if [ -f ".cargo/config.toml" ]; then
        echo "  .cargo/config.toml found"
    else
        echo "  Warning: .cargo/config.toml not found in $(pwd)"
    fi

    if ! cargo build --release --target $TARGET $FEAT_FLAGS; then
        echo "  Error: Build failed for feature set: $feat"
        exit 1
    fi

    # Check if link.x was generated by cortex-m-rt
    LINK_X_PATH=$(find target/$TARGET/release/build/cortex-m-rt-*/out/ -name "link.x" 2>/dev/null | head -1)
    if [ -n "$LINK_X_PATH" ]; then
        echo "  link.x found at: $LINK_X_PATH"
    else
        echo "  Warning: link.x not found in build output"
    fi

    # Get binary path
    BINARY_PATH="target/$TARGET/release/$BINARY_NAME"

    echo "  Checking binary at: $BINARY_PATH"
    if [ ! -f "$BINARY_PATH" ]; then
        echo "  Error: Binary not found at $BINARY_PATH"
        exit 1
    fi

    # Log binary info for debugging
    BINARY_SIZE=$(ls -lh "$BINARY_PATH" | awk '{print $5}')
    echo "  Binary file size: $BINARY_SIZE"

    # Extract size information using berkeley format
    echo "  Running size analysis..."

    # Try rust-size from llvm-tools first (more reliable in CI)
    if command -v rust-size &> /dev/null; then
        SIZE_OUTPUT=$(rust-size --format=berkeley "$BINARY_PATH" 2>&1)
        SIZE_TOOL="rust-size"
    else
        # Fall back to cargo size
        SIZE_OUTPUT=$(cargo size --release --target $TARGET $FEAT_FLAGS 2>&1)
        SIZE_TOOL="cargo size"
    fi

    if [ $? -ne 0 ]; then
        echo "  Warning: $SIZE_TOOL failed"
        echo "  Output: $SIZE_OUTPUT"
    fi

    # Extract sections using berkeley format (shows text, data, bss)
    # Berkeley format output: "   text    data     bss     dec     hex filename"
    TEXT=$(echo "$SIZE_OUTPUT" | tail -1 | awk '{print $1}')
    DATA=$(echo "$SIZE_OUTPUT" | tail -1 | awk '{print $2}')
    BSS=$(echo "$SIZE_OUTPUT" | tail -1 | awk '{print $3}')

    # Validate we got numeric values
    if ! [[ "$TEXT" =~ ^[0-9]+$ ]]; then
        echo "  Warning: TEXT is not numeric: '$TEXT'"
        echo "  SIZE_OUTPUT was: $SIZE_OUTPUT"
        TEXT=0
    fi
    if ! [[ "$DATA" =~ ^[0-9]+$ ]]; then
        DATA=0
    fi
    if ! [[ "$BSS" =~ ^[0-9]+$ ]]; then
        BSS=0
    fi

    # Log warning if binary has no code (helps debug CI issues)
    if [ "$TEXT" = "0" ] && [ "$DATA" = "0" ] && [ "$BSS" = "0" ]; then
        echo "  Warning: Binary appears empty (text=$TEXT, data=$DATA, bss=$BSS)"
        echo "  This may indicate a linker or build issue"
        echo "  SIZE_OUTPUT: $SIZE_OUTPUT"

        # Try to dump section headers to see what sections exist
        if command -v rust-objdump &> /dev/null; then
            echo "  Section headers (via rust-objdump):"
            rust-objdump -h "$BINARY_PATH" 2>&1 | grep -E "^\s*[0-9]+\s+\." | head -10
        elif command -v arm-none-eabi-objdump &> /dev/null; then
            echo "  Section headers (via arm-none-eabi-objdump):"
            arm-none-eabi-objdump -h "$BINARY_PATH" 2>&1 | grep -E "^\s*[0-9]+\s+\." | head -10
        fi
    fi

    # Get detailed section breakdown using -A format for rodata
    SIZE_DETAIL=$(cargo size --release --target $TARGET $FEAT_FLAGS -- -A 2>/dev/null) || true
    RODATA=$(echo "$SIZE_DETAIL" | grep "^\.rodata" | awk '{print $2}' || echo "0")

    # Calculate total flash (in berkeley format, text already includes rodata)
    # text column = .text + .rodata + .vector_table in most cases
    TOTAL_FLASH=$TEXT

    # Store for summary table
    # Note: berkeley format combines .text + .rodata, show rodata separately if available
    if [ -n "$RODATA" ] && [ "$RODATA" != "0" ]; then
        SUMMARY_ROWS+=("| $FEAT_NAME | ${TEXT}B | ${RODATA}B | ${DATA}B | ${BSS}B | ${TOTAL_FLASH}B |")
    else
        SUMMARY_ROWS+=("| $FEAT_NAME | ${TEXT}B | (incl. in .text) | ${DATA}B | ${BSS}B | ${TOTAL_FLASH}B |")
    fi

    # Detailed analysis section
    cat >> "$REPORT" <<EOF

---

## Feature Set: \`$FEAT_NAME\`

### Binary Size Breakdown

\`\`\`
EOF

    # Use cargo size with berkeley format for memory sections
    cargo size --release --target $TARGET $FEAT_FLAGS >> "$REPORT" 2>&1 || true

    cat >> "$REPORT" <<EOF


Detailed sections:
EOF

    # Also show detailed section breakdown
    cargo size --release --target $TARGET $FEAT_FLAGS -- -A >> "$REPORT" 2>&1 || true

    cat >> "$REPORT" <<EOF
\`\`\`

### Top 10 Largest Symbols (Flash Usage)

\`\`\`
EOF

    # Run cargo-bloat for symbol-level analysis
    # Note: May fail if symbols are stripped
    BLOAT_OUTPUT=$(cargo bloat --release --target $TARGET $FEAT_FLAGS -n 10 2>&1 || echo "Symbol analysis not available (binary may be stripped)")
    echo "$BLOAT_OUTPUT" >> "$REPORT"

    cat >> "$REPORT" <<EOF
\`\`\`

EOF

    echo "  ✓ Complete"
done

# Now generate the report header with summary table
TEMP_REPORT="${REPORT}.tmp"
mv "$REPORT" "$TEMP_REPORT"

cat > "$REPORT" <<EOF
# nut-shell Memory Footprint Analysis

**Generated:** $(TZ='Europe/Copenhagen' date)  
**Target:** $TARGET (ARMv6-M, Cortex-M0/M0+)  
**Optimization:** \`opt-level = "z"\`, LTO enabled

This analysis uses a minimal reference binary with an empty directory tree to measure
the pure overhead of nut-shell with different feature combinations.

## Summary Table

| Feature Set | .text (Flash) | .rodata (Flash) | .data (RAM) | .bss (RAM) | Total Flash |
|-------------|---------------|-----------------|-------------|------------|-------------|
EOF

# Add summary rows to table
for row in "${SUMMARY_ROWS[@]}"; do
    echo "$row" >> "$REPORT"
done

# Append the detailed sections
cat "$TEMP_REPORT" >> "$REPORT"
rm "$TEMP_REPORT"

# Add interpretation section
cat >> "$REPORT" <<EOF

---

## Interpretation Guide

**Build configuration:** Release build optimized for size (\`opt-level = "z"\`, LTO enabled) targeting $TARGET (Cortex-M0/M0+).

### Section Meanings

- **.text**: Executable code (stored in Flash)
- **.rodata**: Read-only data like string literals (stored in Flash)
- **.data**: Initialized variables (stored in Flash, copied to RAM at startup)
- **.bss**: Uninitialized/zero-initialized variables (RAM only, no Flash cost)

### Total Memory Cost

- **Flash usage** = .text + .rodata + .data
- **RAM usage** = .data + .bss + stack

### Understanding Generic Type Sizes

nut-shell is generic over several user-provided types. The analysis uses **zero-size stubs** to measure only nut-shell's contribution.

**Your implementations have two cost components:**

#### Runtime Size (RAM - struct instance on stack)

| Generic Type | Analysis Uses | Typical Real Implementation |
|--------------|---------------|------------------------------|
| \`CharIo\` | Zero-size \`MinimalIo\` (0 bytes) | Simple UART (~4-8 bytes), buffered UART (~64-128 bytes), or USB CDC-ACM (~340+ bytes with packet buffers) |
| \`CredentialProvider\` | Zero-size \`MinCredentials\` (0 bytes) | Zero-size build-time (0 bytes), static array reference (~4-8 bytes), or flash-backed (~8-16 bytes) |
| \`CommandHandler\` | Zero-size \`MinHandlers\` (0 bytes) | Stateless (0 bytes) or stateful (depends on fields) |

#### Code Size (Flash - trait implementation logic)

Beyond the struct size, your trait implementations add Flash code:

- **\`CharIo\`**:
  - Simple UART: ~100-200 bytes (register read/write only)
  - Buffered UART: ~500 bytes (ring buffer management)
  - USB CDC-ACM: ~1-3KB (packet handling + USB protocol)
- **\`CredentialProvider\`**:
  - Static array lookup: ~500 bytes - 1KB (linear search + constant-time compare)
  - Flash-backed storage: ~1-3KB (flash I/O + deserialization + crypto)
- **\`CommandHandler\`**:
  - Your command implementations (varies widely: simple GPIO toggle ~50 bytes, complex network request ~2-5KB per command)

**This analysis measures only nut-shell's code.** Your trait implementations add additional Flash/RAM costs on top.

#### Buffer Configuration (RAM cost in .bss)

Runtime buffers are defined via \`ShellConfig\` and allocated in the \`Shell\` struct instance. The analysis uses **\`MinimalConfig\`** (smaller buffers than \`DefaultConfig\`) to isolate nut-shell's code overhead from your application's RAM budget.

**\`MinimalConfig\` buffer sizes:**

\`\`\`rust
const MAX_INPUT: usize = 64;          // vs. 128 (DefaultConfig)
const MAX_PATH_DEPTH: usize = 4;      // vs. 8 (DefaultConfig)
const MAX_ARGS: usize = 8;            // vs. 16 (DefaultConfig)
const MAX_PROMPT: usize = 32;         // vs. 64 (DefaultConfig)
const MAX_RESPONSE: usize = 128;      // vs. 256 (DefaultConfig)

#[cfg(feature = "history")]
const HISTORY_SIZE: usize = 4;        // vs. 10 (DefaultConfig)

#[cfg(not(feature = "history"))]
const HISTORY_SIZE: usize = 0;        // 0 when history disabled
\`\`\`

**RAM scales linearly with buffer sizes.** Doubling \`MAX_INPUT\` adds ~64 bytes RAM (but Flash stays constant).

**History buffer RAM cost** = \`HISTORY_SIZE × MAX_INPUT\` = 4 × 64 = ~256 bytes (when history enabled).

#### Message Configuration (Flash cost in .rodata)

User-visible messages (welcome, login prompts, errors) are defined via \`ShellConfig\` as const strings. The analysis uses **\`MinimalConfig\`** (shorter messages than \`DefaultConfig\`) to minimize .rodata overhead.

**\`MinimalConfig\` messages:**

\`\`\`rust
const MSG_WELCOME: &'static str = "Welcome!";                                  // 8 bytes vs. 21 (DefaultConfig)
const MSG_LOGIN_PROMPT: &'static str = "Login> ";                              // 7 bytes vs. 7 (DefaultConfig)
const MSG_LOGIN_SUCCESS: &'static str = "Logged in.";                          // 10 bytes vs. 34 (DefaultConfig)
const MSG_LOGIN_FAILED: &'static str = "Login failed.";                        // 13 bytes vs. 26 (DefaultConfig)
const MSG_LOGOUT: &'static str = "Logged out.";                                // 11 bytes vs. 11 (DefaultConfig)
const MSG_INVALID_LOGIN_FORMAT: &'static str = "Invalid format. Use <name>:<password>";  // 38 bytes vs. 45 (DefaultConfig)
\`\`\`

**Total message overhead:**
- \`MinimalConfig\`: ~87 bytes
- \`DefaultConfig\`: ~144 bytes

**Both buffers and messages are fully customizable** via the \`ShellConfig\` trait to match your application's needs and hardware constraints.

### Feature Impact Summary

Compare the "none" baseline with feature-enabled builds to see the cost of each feature:

| Feature Set | Flash (Code) | RAM (Data) | Notes |
|-------------|--------------|------------|-------|
| authentication | ~2-3KB | ~100 bytes | SHA-256 hashing, login state machine |
| completion | ~1-2KB | ~0 bytes | Prefix matching (stateless) |
| history | ~1KB | HISTORY_SIZE × MAX_INPUT | Command history buffer (10 × 128 = ~1.3KB default) |
| async | ~1KB | ~0 bytes | Async runtime integration (stateless) |

**Note:** Flash costs are the compiled code for each feature. RAM costs are the runtime state/buffers.

EOF

printf "\n"
printf "${GREEN}✓ Analysis complete!${NC}\n"
printf "Report generated at: ${BLUE}%s${NC}\n" "$REPORT"
printf "\n"
echo "To view the report:"
echo "  cat $REPORT"
echo "  or open $REPORT in your editor"

# Clean up build artifacts
printf "\n"
printf "${GREEN}Cleaning up build artifacts...${NC}\n"
cargo clean --quiet
cd ..
